# 正则表达式（re库）
---
python中使用正则表达式
```py
import re
```

## 1. 语法
### 1.1 特殊字符
#### 1.1.1 元字符
| 特殊字符     | 含义     | 
| -------- | -------- | 
| . | (点号) 在默认模式下，匹配除换行符以外的任意字符。 如果指定了旗标`DOTALL`，它将匹配包括换行符在内的任意字符。 | 
| ^ | (插入符) 匹配字符串的开头， 并且在`MULTILINE`模式下也匹配换行后的首个符号。 | 
| $ | 匹配字符串尾或者在字符串尾的换行符的前一个字符，在`MULTILINE`模式下也会匹配换行符之前的文本。`foo`匹配`'foo'`和`'foobar'`，但正则表达式`foo$`只匹配 `'foo'`。 更有趣的是，在`'foo1\nfoo2\n'`中搜索`foo.$`，通常匹配`'foo2'`，但在`MULTILINE`模式下可以匹配到`'foo1'`；在`'foo\n'`中搜索`$`会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。 | 
| * | 对它前面的正则式匹配0到任意次重复， ==尽量多的匹配字符串==。 `ab*`会匹配`'a'`，`'ab'`，或者`'a'`后面跟随任意个`'b'`。 | 
| + | 对它前面的正则式匹配1到任意次重复，==尽量多的匹配字符串==。 `ab+`会匹配`'a'`后面跟随1个以上到任意个`'b'`，它不会匹配`'a'`。 | 
| ? | 对它前面的正则式匹配0到1次重复，==尽量多的匹配字符串==。`ab?`会匹配`'a'`或者`'ab'`。 | 
| `*?`, `+?`, `??` | `'*'`, `'+'` 和 `'?'` 数量限定符都是 贪婪的；它们会匹配尽可能多的文本。 有时这种行为并不被需要；如果 RE `<.*>` 针对 `'<a> b <c>'` 进行匹配，它将匹配整个字符串，而不只是 `'<a>'`。 在数量限定符之后添加 `?` 将使其以 非贪婪 或 最小 风格来执行匹配；也就是将匹配数量尽可能 少的 字符。 使用 RE `<.*?>` 将只匹配 `'<a>'`。 | 
| `*+`, `++`, `?+` | 类似于 `'*'`, `'+'`和`'?'`数量限定符，添加了 `'+'` 的形式也将匹配尽可能多的次数。但是，不同于真正的贪婪型数量限定符，这些形式在之后的表达式匹配失败时==不允许反向追溯==。这些形式被称为 占有型 数量限定符。 例如，`a*a` 将匹配 `'aaaa'` 因为 `a*` 将匹配所有的 4 个 `'a'`，但是，当遇到最后一个 `'a'` 时，表达式将执行反向追溯以便最终 `a*` 最后变为匹配总计 3 个 `'a'`，而第四个 `'a'` 将由最后一个 `'a'` 来匹配。 然而，当使用 `a*+a` 时如果要匹配 `'aaaa'`，`a*+` 将匹配所有的 4 个 `'a'`，但是在最后一个 `'a'` 无法找到更多字符来匹配时，表达式将无法被反向追溯并将因此匹配失败。 `x*+`, `x++` 和 `x?+` 分别等价于 `(?>x*)`, `(?>x+)` 和 `(?>x?)` | 
| {m} | 对其之前的正则式指定匹配`m`个重复；少于 `m` 的话就会导致匹配失败。比如， `a{6}` 将匹配6个`'a'`, 但是不能是5个。 | 
| {m,n} | 对正则式进行 m 到 n 次匹配，==在 m 和 n 之间取尽量多==。 比如，`a{3,5}` 将匹配 3 到 5个 `'a'`。忽略 m 意为指定下界为0，忽略 n 指定上界为无限次。 比如 `a{4,}b` 将匹配 `'aaaab'` 或者1000个 `'a'` 尾随一个 `'b'`，但不能匹配 `'aaab'`。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。 | 
| {m,n}? | 将导致结果 RE 匹配之前 RE 的 m 至 n 次重复，尝试匹配尽可能 少的 重复次数。 这是之前数量限定符的非贪婪版本。 例如，在 6 个字符的字符串 'aaaaaa' 上，a{3,5} 将匹配 5 个 'a' 字符，而 a{3,5}? 将只匹配 3 个字符。 | 
| {m,n}+ | 将导致结果 RE 匹配之前 RE 的 m 至 n 次重复，尝试匹配尽可能多的重复而 不会 建立任何反向追溯点。 这是上述数量限定符的占有型版本。 例如，在 6 个字符的字符串 `'aaaaaa'` 上，`a{3,5}+aa` 将尝试匹配 5 个 `'a'` 字符，然后，要求再有 2 个 `'a'`，这将需要比可用的更多的字符因而会失败，而 `a{3,5}aa` 的匹配将使 `a{3,5}` 先捕获 5 个，然后通过反向追溯再匹配 4 个 `'a'`，然后用模式中最后的 `aa` 来匹配最后的 2 个 `'a'`。 `x{m,n}+` 就等同于 `(?>x{m,n})`。 | 
| \ | 转义特殊字符（允许你匹配 `'*'`, `'?'`, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。如果你没有使用原始字符串（ `r'raw'` ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。 | 
| [] | 用于表示一个字符集合。在一个集合中：字符可以单独列出，比如 `[amk]` 匹配 `'a'`， `'m'`， 或者 `'k'`。 可以表示字符范围，通过用 `'-'` 将两个字符连起来。比如 `[a-z]` 将匹配任何小写ASCII字符， `[0-5][0-9]` 将匹配从 `00` 到 `59` 的两位数字， `[0-9A-Fa-f]` 将匹配任何十六进制数位。 如果 `-` 进行了转义 （比如 `[a\-z]`）或者它的位置在首位或者末尾（如 `[-a]` 或 `[a-]`），它就只表示普通字符 `'-'`。 特殊字符在集合中会失去其特殊意义。比如 `[(+*)]` 只会匹配这几个字面字符之一 `'('`, `'+'`, `'*'`, or `')'`。更多详情参考官网 | 
| &#124; | A&#124;B， A 和 B 可以是任意正则表达式，创建一个正则表达式，匹配 A 或者 B. 任意个正则表达式可以用 '&#124;' 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， '&#124;' 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 A 匹配成功， B 就不再进行匹配，即便它能产生一个更好的匹配。或者说，'&#124;' 操作符绝不贪婪。 如果要匹配 '&#124;' 字符，使用 \ &#124;， 或者把它包含在字符集里，比如 [&#124;]. | 
| `[\u4E00-\u9FA5]` | 匹配汉字 | 

**注意点**
1. `'*'`, `'+'` 和 `'?'` 数量限定符都是 贪婪的；==它们会匹配尽可能多的文本==。 
2. 反向追溯：https://blog.csdn.net/qq_40241957/article/details/98624159

#### 1.1.2（）特殊字符**
| 特殊字符     | 含义     | 
| -------- | -------- | 
| (...) | （组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。==匹配完成后，组合的内容可以被获取，并可以在之后用 \number 转义序列进行再次匹配==，之后进行详细说明。要匹配字符 `'('` 或者 `')'`, 用 `\(` 或 `\)`, 或者把它们包含在字符集合里: `[(]`, `[)]`. | 
| (?…) | 这是个扩展标记法 （一个 `'?'` 跟随 `'('` 并无含义）。 `'?'` 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； `(?P<name>...)` 是唯一的例外。 以下是目前支持的扩展。 | 

未完

组合匹配是非贪婪的，其匹配到的第一个字符串作为值被获取。


#### 1.1.3 `\` 特殊字符
| 特殊字符     | 含义     | 
| -------- | -------- | 
| \number | 匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 `(.+) \1` 匹配 `'the the'` 或者 `'55 55'`, 但不会匹配 `'thethe'` (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 number 的第一个数位是0， 或者 number 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 '[' 和 ']' 字符集合内，任何数字转义都被看作是字符。 | 
| \A | 只匹配字符串开始。 | 
| \b | 匹配空字符串，但只在单词开始或结尾的位置。 一个单词被定义为一个单词字符的序列。 注意在通常情况下，`\b` 被定义为 `\w` 和 `\W` 字符之间的边界（反之亦然），或是 `\w` 和字符串开始或结尾之间的边界。 这意味着 `r'\bat\b'` 将匹配 `'at'`, `'at.'`, `'(at)'` 和 `'as at ay'` 但不匹配 `'attempt'` 或 `'atlas'`。 | 
| \B | 匹配空字符串，但仅限于它 ==不在== 单词的开头或结尾的情况。 这意味着 `r'at\B'` 将匹配 `'athens'`, `'atom'`, `'attorney'`，但不匹配 `'at'`, `'at.'` 或 `'at!'`。  | 
| \d | 对于 `Unicode (str)` 样式：匹配任意 `Unicode` 十进制数码（也就是说，任何属于 `Unicode` 字符类别 [Nd] 的字符），这包括 `[0-9]`，还包括许多其他的数码类字符；如果使用了 `ASCII` 旗标则匹配 `[0-9]`；对于8位(bytes)样式：匹配 `ASCII` 字符集内的任意十进制数码；这等价于 `[0-9]`。 | 
| \D | 匹配不属于十进制数码的任意字符。 这与 `\d` 正相反。如果使用了 ASCII 旗标则匹配 `[^0-9]` | 
| \s | 匹配 Unicode 空白字符（这包括 `[ \t\n\r\f\v]`，还包括许多其他字符，例如许多语言中由排版规则约定的非中断空白字符）。如果使用了 ASCII 旗标则匹配 `[ \t\n\r\f\v]`;对于8位(bytes)样式：匹配ASCII中的空白字符，就是 `[ \t\n\r\f\v]` | 
| \S | 匹配不属于空白字符的任意字符。 这与 `\s` 正相反。如果使用了 ASCII 旗标则匹配 `[^ \t\n\r\f\v]` | 
| \w | 匹配 Unicode 单词类字符；这包括所有 Unicode 字母数字类字符 (由 str.isalnum() 定义)，以及下划线 `(_)`；如果使用了 ASCII 旗标则匹配 `[a-zA-Z0-9_]`。 | 
| \W | 匹配不属于单词类字符的任意字符。 这与 `\w` 正相反。 在默认情况下，将匹配除下划线 `(_)` 以外的 `str.isalnum()` 返回 `False` 的字符。如果使用了 ASCII 旗标则匹配 `[^a-zA-Z0-9_]`。 | 
| \Z | 只匹配字符串尾。 | 

**注意点**
1. ==注意`\`容易被转义，比如`\`后面跟三个八进制数或者十六进制数。==

### 1.2 反斜杠的匹配（难点）
在学习正则表达式的过程中，遇到了一直无法正确匹配反斜杠`\`，初始使用的是下面两种方法：
- 使用普通字符串，匹配一个反斜杠，需要再用一个反斜杠来转义：`\\`
- 使用带r的原始字符串，这样就不用再转义：`r'\'`（这个会报错，python会提示你缺少右`'`，内心OS：emmm……）

使用上面两种方法一直无法匹配 `4\5` 中的反斜杠，最终经过查询，发现自己理解错误，==**字符串存在转义，正则也存在转义**==

**字符串转义**
在字符串中，我们会用一反斜杠加特定的字符来表达一些特定的功能，比如，`\n`表示换行，`\"`表示双引号等等，而如果要输出反斜杠本身，则用`\\`如下所示
```py
str="\"Hello\\\nWorld\""
print(str)

结果：
"Hello\
World"
```
可以看到，先是`\"`被转义成了一个双引号`"`，然后是`\\`转义成`\`，然后`\n`转义为换行，最后是`\"`转义成`"`. (这里不会二次转义，比如`\\n`，只会转义成`\n`，不会再次将`\n`转义成换行)

但当你在字符串前面加一个r，表示初始字符串，此时解释器将不对字符串里面的特殊字符进行转义，最外层双引号里面是什么内容，即为什么样的内容，所见即所得
```py
str=r"\"Hello\\\nWorld\""
print(str)

结果：
\"Hello\\\nWorld\"
```

**正则转义**
在正则表达式中会使用一些通配符，比如`\w`表示匹配字母，数字或者下划线；`\s`表示空白字符；`\d`匹配数字
因此，若要实现正则转义，首先要保证模式字符串里面有反斜杠：

- 比如字符串`\n`，里面就没有反斜杠，因为反斜杠连同后面的 n 已经被字符串转义成 换行；
- 字符串`\d`，这里面是存在反斜杠的，因为字符串转义里面`\d`没有特定功能，所以仍然保留`\d`，然后正则转义在根据得到的`\d`进行转义，得到数字匹配。
- 对于使用原始字符串r的，此时就是将整个初始字符串传给模式字符串；比如`r'\n'`，此时就是将整个`\n`传递给正则表达式

```py
>>> x = re.compile('\n') #先是字符串转义成回车，匹配回车
>>> print(x.search('abc\nabc')) #提供的是 回车
<re.Match object; span=(3, 4), match='\n'> # 因此能匹配到

>>> x = re.compile(r'\n') #匹配 \n 2个字符
>>> print(x.search('abc\nabc')) #提供的是 回车，即 \n 2个字符 
<re.Match object; span=(3, 4), match='\n'> #因此能匹配到
>>> print(x.search(r'abc\nabc')) #提供的是正则里面的 \n 两个字符，会被回转成 \\n
None

>>> x = re.compile('\\n') #匹配 \n 两个字符
>>> print(x.search(r'abc\nabc')) #提供的是正则里面的 \n 两个字符，会被回转成 \\n
None

>>> x = re.compile(r'\\n')  #匹配 \\n 三个字符
>>> print(x.search(r'abc\nabc')) #提供的正则里面的 \n两个字符，会被回转成 \\n 
<re.Match object; span=(3, 5), match='\\n'> #因此能匹配到
```

因此，正则表达式的解释分为两部分：

1. 第一步，字符串进行转义，将转义后的结果传给模式字符串
2. 第二步，正则对得到的模式字符串进行转义，然后再进行匹配


### 1.3 组和反向引用
**组的概念**


**反向引用**

`\1` `\2`后面带数字的就是反向引用，一定要和组一起使用才是反向引用，不然就是转义字符，为了避免被python字符串转义，通常pattern前面需要加`r`

其中数字1、2是组合编号，从1开始编号，最多只能到99。例如`r'(.+) \1'`这里的`\1`表示再次匹配第一个组合的值，==记住是值！！！== 也就是说只有当`'(.+)'`匹配到确定值以后再传入`r'(.+) \1'`进行再次匹配，举个栗子，如果`'(.+)'`匹配到的是`the`，那么`the`传入初始正则表达式`r'(.+) \1'`变成`r'(the) \1'`并进行再次匹配，而`r'(the) \1'`就等于`r'(the) (the)'`

同理`\2`~`\99`是同样的用法，`r'(a)(b)\2'`等同于`r'(a)(b)(b)'`

当使用`match.group(n)`获取字符串的时候，组0即整个字符串。

**匹配模式**（包含反向引用和回溯）

源字符串：`abcdebbcde`

正则表达式：`r'([ab])\1'`

对于正则表达式`r'([ab])\1'`，捕获组中的子表达式`[ab]`虽然可以匹配`'a'`或者`'b'`，但是捕获组一旦匹配成功，反向引用的内容也就确定了。如果捕获组匹配到`'a'`，那么反向引用也就只能匹配`'a'`，同理，如果捕获组匹配到的是`'a'`，那么反向引用也就只能匹配`'a'`。由于后面反向引用`\1`的限制，要求必须是两个相同的字符，在这里也就是`'aa'`或者`'bb'`才能匹配成功。

考察一下这个正则表达式的匹配过程，在位置0处，由`([ab])`匹配`'a'`成功，将捕获的内容保存在编号为1的组中，然后把控制权交给`\1`，由于此时捕获组已记录了捕获内容为`'a'`，`\1`也就确定只有匹配到`'a'`才能匹配成功，这里显然不满足，`\1`匹配失败，由于没有可供回溯的状态，整个表达式在位置0处匹配失败。

正则引擎向前传动，在位置5之前，`([ab])`一直匹配失败。传动到位置5处时，，`([ab])`匹配到`'b'`，匹配成功，将捕获的内容保存在编号为1的组中，然后把控制权交给“\1”，由于此时捕获组已记录了捕获内容为`'b'`，`\1`也就确定只有匹配到“b”才能匹配成功，满足条件，`\1`匹配成功，整个表达式匹配成功，匹配结果为`'bb'`，匹配开始位置为5，结束位置为7。

扩展一下，正则表达式`r'([a-z])\1{2}'`也就表达连续三个相同的小写字母。

## 2. 模块内容
### 2.1 标志
### 2.2 函数
**re.compile(pattern, flags=0)**
将正则表达式的样式编译为一个正则表达式对象（正则对象），可以用于匹配

**re.search(pattern, string, flags=0)**
==扫描整个==`string`查找正则表达式`pattern`产生匹配的第一个位置，并返回相应的`Match`。 如果字符串中没有与模式匹配的位置则返回`None`；请注意这不同于在字符串的某个位置上找到零长度匹配。

**re.match(pattern, string, flags=0)**
如果`string`==开头的零个或多个字符==与正则表达式`pattern`匹配，则返回相应的`Match`。 如果字符串与模式不匹配则返回`None`；请注意这与零长度匹配是不同的。

注意即便是`MULTILINE`多行模式，`re.match()`也只匹配字符串的开始位置，而不匹配每行开始。

如果你想定位`string`的任何位置，使用`search()` 来替代。

**re.fullmatch(pattern, string, flags=0)**
如果整个`string`与正则表达式`pattern`匹配，则返回相应的`Match`。如果字符串与模式不匹配则返回`None`；请注意这与零长度匹配是不同的。

**re.split(pattern, string, maxsplit=0, flags=0)**
用`pattern`分开`string`。如果在`pattern`中捕获到括号，那么所有的组里的文字也会包含在列表里。如果`maxsplit`非零， 最多进行`maxsplit`次分隔，剩下的字符全部返回到列表的最后一个元素。

**re.findall(pattern, string, flags=0)**
返回 `pattern` 在 `string` 中的所有==非重叠匹配== （注意：值可以一样），以字符串列表或字符串元组列表的形式。对 `string` 的扫描从左至右，匹配结果按照找到的顺序返回。 空匹配也包括在结果中。

返回结果取决于模式中捕获组的数量。如果没有组，返回与整个模式匹配的字符串列表。如果有且仅有一个组，返回与该组匹配的字符串列表。如果有多个组，返回与这些组匹配的字符串元组列表。非捕获组不影响结果。



### 2.3 异常

## 2. 正则表达式对象（正则对象）

## 3. 匹配对象
**class re.Match**
由成功的 `match` 和 `search` 所返回的匹配对象。

**Match.group([group1, ...])**
返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1~99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 IndexError 异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:
```py
>>>str = r"56 67"
>>>patt1 = r"(.)(.) \2"
>>>print(re.match(patt1, str).group()) # 等价于group(0)
'56 6'
>>>print(re.match(patt1, str).group(0)) # 指匹配整个正则式的整个字符串
'56 6'
>>>print(re.match(patt1, str).group(1)) # 指匹配第1个组合的字符串
'5'
>>>print(re.match(patt1, str).group(2)) # 指匹配第2个组合的字符串
'6'
```

**Match.groups(default=None)**
返回一个元组，包含所有匹配的==子组==，在样式中出现的从1到任意多的组合。 default 参数用于不参与匹配的情况，默认为 None。
```py
>>>str = r"56 67"
>>>patt1 = r"(.)(.) \2"
>>>print(re.match(patt1, str).groups()) # 不包括group(0)！！
('5', '6')
```

---
# 【引用】

1. RE库官网（中文） https://docs.python.org/zh-cn/3/library/re.html#regular-expression-syntax
2. 正则表达式 反斜杠的匹配 https://www.cnblogs.com/qiulinzhang/p/10045647.html
3. 正则表达式回溯法原理 https://blog.csdn.net/qq_40241957/article/details/98624159