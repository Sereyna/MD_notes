# spring 事务
## 什么是事务？
我们在开发企业应用时，通常业务人员的一个操作实际上是对数据库读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作的数据并不可靠，如果要让这个业务正确的执行下去，通常有实现方式：

1. 记录失败的位置，问题修复之后，从上一次执行失败的位置开始继续执行后面要做的业务逻辑
2. 在执行失败的时候，回退本次执行的所有过程，让操作恢复到原始状态，带问题修复之后，重新执行原来的业务逻辑

事务就是针对上述方式2的实现。事务，一般是指要做的或所做的事情，就是上面所说的业务人员的一个操作（比如电商系统中，一个创建订单的操作包含了创建订单、商品库存的扣减两个基本操作。如果创建订单成功，库存扣减失败，那么就会出现商品超卖的问题，所以最基本的最发就是需要为这两个操作用事务包括起来，保证这两个操作要么都成功，要么都失败）。

这样的场景在实际开发过程中非常多。

## 快速入门
这里主要通过单元测试演示了如何使用`@Transactional`注解来声明一个函数需要被事务管理，通常我们单元测试为了保证每个测试之间的数据独立，会使用`@Rollback`注解让每个单元测试都能在结束时回滚。而真正在开发业务逻辑时，我们通常在service层接口中使用`@Transactional`来对各个业务逻辑进行事务管理的配置，例如：

```java
public interface UserService {
    
    @Transactional
    User update(String name, String password);
    
}
```

## 事务详解
上面的例子中我们使用了默认的事务配置，可以满足一些基本的事务需求，但是当我们项目较大较复杂时（比如，有多个数据源等），这时候需要在声明事务时，指定不同的事务管理器。在声明事务时，只需要通过value属性指定配置的事务管理器名即可，例如：`@Transactional(value="transactionManagerPrimary")`。

除了指定不同的事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：

### 隔离级别
隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读、重复读、幻读。

我们可以看`org.springframework.transaction.annotation.Isolation`枚举类中定义了五个表示隔离级别的值：

```java
public enum Isolation {
    DEFAULT(-1),
    READ_UNCOMMITTED(1),
    READ_COMMITTED(2),
    REPEATABLE_READ(4),
    SERIALIZABLE(8);
}
```
| 隔离级别 | 隔离级别的值 | 导致的问题 |
| ---- | ---- | ---- |
| default | -1 | 这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED |
| Read-Uncommitted | 1 | 脏读 |
| Read-Commited | 2 | 避免脏读，允许重复读、幻读 |
| Repeatable-Read | 4 | 避免脏读、重复读，允许幻读 |
| Serializable | 8 | 串行化读，事务只能一个一个执行，避免了脏读、重复读、幻读，执行效率慢，慎重使用 |

- 脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。

- 不可重复读：一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。

- 幻读：第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。

指定方法：通过使用isolation属性设置，例如：

```java
@Transactional(isolation = Isolation.DEFAULT)
```

### 传播行为
所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。

我们可以看`org.springframework.transaction.annotation.Propagation`枚举类中定义了6个表示传播行为的枚举值：

```java
public enum Propagation {
    REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);
}
```

| 传播行为 | 解释 |
| ---- | ---- |
| REQUIRED | 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。 |
| SUPPORTS | 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 |
| MANDATORY | 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。读 |
| REQUIRES_NEW | 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 |
| NOT_SUPPORTED | 以非事务方式运行，如果当前存在事务，则把当前事务挂起。 |
| NEVER | 以非事务方式运行，如果当前存在事务，则抛出异常。 |
| NESTED | 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED。 |

指定方法：通过使用propagation属性设置，例如：

```java
@Transactional(propagation = Propagation.REQUIRED)
```